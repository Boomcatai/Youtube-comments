<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
            <meta name="description" content="Descarga todos los comentarios de videos de YouTube, incluyendo sus respuestas. Hasta 10.000 comentarios.">
        <meta name="keywords" content="YouTube, comentarios, descarga, extractor, respuestas, PDF, TXT">
        <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>üß†</text></svg>"
    <title></title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        :root {
            --primary-color: #ff0000;
            --secondary-color: #333333;
            --accent-color: #4285f4;
            --light-gray: #f5f5f5;
            --dark-gray: #666666;
            --white: #ffffff;
            --success-color: #34a853;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Roboto', Arial, sans-serif;
        }

        body {
            background-color: var(--light-gray);
            color: var(--secondary-color);
            line-height: 1.6;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px 0;
            background-color: var(--white);
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        h1 {
            color: var(--primary-color);
            font-size: 2.5rem;
            margin-bottom: 10px;
        }

        .subtitle {
            color: var(--dark-gray);
            font-size: 1.2rem;
        }

        .input-container {
            background-color: var(--white);
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 25px;
        }

        .input-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: var(--secondary-color);
        }

        input[type="text"] {
            width: 100%;
            padding: 12px 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            font-size: 16px;
            transition: border-color 0.3s;
        }

        input[type="text"]:focus {
            border-color: var(--accent-color);
            outline: none;
            box-shadow: 0 0 5px rgba(66, 133, 244, 0.3);
        }

        .radio-group {
            display: flex;
            gap: 20px;
            margin-top: 10px;
        }

        .radio-option {
            display: flex;
            align-items: center;
            cursor: pointer;
        }

        .radio-option input {
            margin-right: 8px;
        }

        button {
            background-color: var(--accent-color);
            color: var(--white);
            border: none;
            padding: 12px 25px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: background-color 0.3s;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        button:hover {
            background-color: #3367d6;
        }

        button:disabled {
            background-color: var(--dark-gray);
            cursor: not-allowed;
        }

        .progress-container {
            background-color: var(--white);
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 25px;
            display: none;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .progress-title {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .progress-stats {
            font-size: 0.9rem;
            color: var(--dark-gray);
        }

        .progress-bar-container {
            width: 100%;
            height: 20px;
            background-color: #e0e0e0;
            border-radius: 10px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background-color: var(--accent-color);
            border-radius: 10px;
            width: 0%;
            transition: width 0.3s ease;
        }

        .results-container {
            background-color: var(--white);
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 25px;
            display: none;
        }

        .results-header {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
        }

        .results-title {
            font-size: 1.4rem;
            color: var(--secondary-color);
            margin-bottom: 10px;
        }

        .results-meta {
            font-size: 0.9rem;
            color: var(--dark-gray);
        }

        .download-options {
            display: flex;
            gap: 15px;
            margin-bottom: 20px;
        }

        .download-btn {
            padding: 10px 20px;
        }

        .download-btn.txt {
            background-color: var(--success-color);
        }

        .download-btn.txt:hover {
            background-color: #2d9249;
        }

        .download-btn.pdf {
            background-color: var(--primary-color);
        }

        .download-btn.pdf:hover {
            background-color: #d32f2f;
        }

        .comments-container {
            max-height: 500px;
            overflow-y: auto;
            border: 1px solid #eee;
            border-radius: 5px;
            padding: 15px;
        }

        .comment {
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 1px solid #eee;
            position: relative;
        }

        .comment-header {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
        }

        .comment-author {
            font-weight: bold;
            margin-right: 10px;
        }

        .comment-date {
            font-size: 0.8rem;
            color: var(--dark-gray);
        }

        .comment-text {
            margin-bottom: 10px;
            line-height: 1.5;
        }

        .comment-meta {
            display: flex;
            gap: 15px;
            font-size: 0.85rem;
            color: var(--dark-gray);
        }

        .comment-meta i {
            margin-right: 5px;
        }

        .replies-container {
            margin-left: 30px;
            padding-left: 15px;
            border-left: 2px solid #eee;
            margin-top: 15px;
        }

        .reply {
            margin-bottom: 15px;
        }

        .reply:last-child {
            margin-bottom: 0;
        }

        .spinner {
            border: 4px solid rgba(0, 0, 0, 0.1);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border-left-color: var(--accent-color);
            animation: spin 1s linear infinite;
            display: inline-block;
            vertical-align: middle;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .hidden {
            display: none;
        }

        .error-message {
            color: var(--primary-color);
            background-color: #ffebee;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            display: none;
        }

        footer {
            text-align: center;
            margin-top: 50px;
            padding: 20px 0;
            color: var(--dark-gray);
            font-size: 0.9rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            header {
                padding: 15px 0;
            }

            h1 {
                font-size: 2rem;
            }

            .input-container, .progress-container, .results-container {
                padding: 15px;
            }

            .download-options {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Youtube Comments</h1>
            <p class="subtitle">Descarga todos los comentarios de cualquier video de YouTube</p>
        </header>

        <main>
            <section class="input-container">
                <div class="input-group">
                    <label for="video-url">URL del video de YouTube:</label>
                    <input type="text" id="video-url" placeholder="https://www.youtube.com/watch?v=..." required>
                    <div class="error-message" id="url-error"></div>
                </div>

                <!-- Hemos eliminado la selecci√≥n de orden y establecido "M√°s recientes" como predeterminado -->

            <div class="input-group">
                <button id="fetch-btn" onclick="fetchComments()">
                    <i class="fas fa-download"></i> Obtener Comentarios
                </button>
                <button id="stop-btn" onclick="stopDownload()" style="display: none; background-color: #d32f2f; margin-left: 10px;">
                    <i class="fas fa-stop"></i> Detener Descarga
                </button>
            </div>
            </section>

            <section class="progress-container" id="progress-section">
                <div class="progress-header">
            <div class="progress-title">Descargando comentarios...</div>
                    <div class="progress-info">
                        <div class="progress-stats" id="progress-stats">0 de ? comentarios</div>
                        <div class="progress-time" id="progress-time">Tiempo estimado: calculando...</div>
                    </div>
                </div>
                <div class="progress-bar-container">
                    <div class="progress-bar" id="progress-bar"></div>
                </div>
            </section>

            <section class="results-container" id="results-section">
                <div class="results-header">
                    <h2 class="results-title" id="video-title">T√≠tulo del video</h2>
                    <p class="results-meta" id="comments-count">0 comentarios descargados</p>
                </div>

                <div class="download-options">
                    <button class="download-btn txt" onclick="downloadAsTxt()">
                        <i class="fas fa-file-alt"></i> Descargar como TXT
                    </button>
                    <button class="download-btn pdf" onclick="downloadAsPdf()">
                        <i class="fas fa-file-pdf"></i> Descargar como PDF
                    </button>
                </div>

                <div class="comments-container" id="comments-container">
                    <!-- Los comentarios se cargar√°n aqu√≠ din√°micamente -->
                </div>
            </section>
        </main>

        <footer>
            <p>Braindog &copy; 2025 | Todos los derechos reservados</p>
        </footer>
    </div>

    <script>
        // Constantes y variables globales
        const DEFAULT_API_KEY = "AIzaSyBpX3-bHfANE-RB5Bx4GDdnvWA8fa1t6Vk";
        let allComments = [];
        let videoData = {
            title: "",
            totalComments: 0
        };
        let commentsFetched = 0;
        let isDownloading = false;
        
        // Variables para protecci√≥n contra limitaci√≥n de API
        let requestsCount = 0;
        const REQUEST_LIMIT = 50; // L√≠mite para evitar exceder cuota
        const REQUEST_DELAY = 500; // Milisegundos de espera entre solicitudes
        
        // Funci√≥n para pausar ejecuci√≥n (para evitar exceder l√≠mites de API)
        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        // Funci√≥n para validar la URL de YouTube
        function validateYoutubeUrl(url) {
            // Validar formato de URL de YouTube
            const youtubeRegex = /^(https?:\/\/)?(www\.)?(youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})(&.*)?$/;
            return youtubeRegex.test(url);
        }

        // Funci√≥n para extraer el ID del video de la URL
        function extractVideoId(url) {
            const regex = /[?&]v=([^&#]*)/;
            const match = url.match(regex);
            
            if (match && match[1]) {
                return match[1];
            }
            
            // Intentar con formato youtu.be
            const shortRegex = /youtu\.be\/([a-zA-Z0-9_-]{11})/;
            const shortMatch = url.match(shortRegex);
            
            if (shortMatch && shortMatch[1]) {
                return shortMatch[1];
            }
            
            return null;
        }

        // Funci√≥n para formatear fecha
        function formatDate(isoString) {
            const date = new Date(isoString);
            return date.toLocaleDateString('es-ES', { 
                year: 'numeric', 
                month: 'short', 
                day: 'numeric' 
            });
        }

        // Funci√≥n para actualizar la barra de progreso
        function updateProgressBar(current, total) {
            const progressBar = document.getElementById('progress-bar');
            const progressStats = document.getElementById('progress-stats');
            
            const percentage = Math.min((current / total) * 100, 100);
            progressBar.style.width = `${percentage}%`;
            progressStats.textContent = `${current} de ${total} comentarios`;
        }

        // Funci√≥n para mostrar errores
        function showError(message) {
            const errorElement = document.getElementById('url-error');
            errorElement.textContent = message;
            errorElement.style.display = 'block';
            
            // Ocultar elementos de progreso si est√°n visibles
            document.getElementById('progress-section').style.display = 'none';
            isDownloading = false;
        }

        // Funci√≥n para limpiar errores
        function clearError() {
            const errorElement = document.getElementById('url-error');
            errorElement.textContent = '';
            errorElement.style.display = 'none';
        }

        // Funci√≥n para obtener informaci√≥n del video
        async function fetchVideoInfo(videoId) {
            try {
                const response = await fetch(`https://www.googleapis.com/youtube/v3/videos?part=snippet,statistics&id=${videoId}&key=${DEFAULT_API_KEY}`);
                const data = await response.json();
                
                if (data.items && data.items.length > 0) {
                    // Verificar si el video tiene el campo commentCount
                    const commentCount = data.items[0].statistics?.commentCount 
                        ? parseInt(data.items[0].statistics.commentCount) 
                        : null;
                    
                    return {
                        title: data.items[0].snippet.title,
                        channelTitle: data.items[0].snippet.channelTitle,
                        commentCount: commentCount
                    };
                } else {
                    throw new Error("No se pudo encontrar informaci√≥n del video");
                }
            } catch (error) {
                console.error("Error al obtener informaci√≥n del video:", error);
                showError("No se pudo obtener informaci√≥n del video. Por favor verifica la URL e intenta de nuevo.");
                return null;
            }
        }

        // Funci√≥n para detener la descarga
        function stopDownload() {
            if (isDownloading) {
                isDownloading = false;
                document.getElementById('fetch-btn').disabled = false;
                document.getElementById('stop-btn').style.display = 'none';
                document.getElementById('progress-section').style.display = 'none';
                showError("Descarga cancelada por el usuario");
            }
        }

        // Funci√≥n para obtener comentarios
        async function fetchComments() {
            clearError();
            const urlInput = document.getElementById('video-url');
            const url = urlInput.value.trim();
            
            if (!url) {
                showError("Por favor ingresa la URL de un video de YouTube");
                return;
            }
            
            if (!validateYoutubeUrl(url)) {
                showError("La URL ingresada no parece ser v√°lida. Por favor ingresa una URL de YouTube correcta");
                return;
            }
            
            const videoId = extractVideoId(url);
            if (!videoId) {
                showError("No se pudo extraer el ID del video de la URL proporcionada");
                return;
            }

            // Deshabilitar el bot√≥n y mostrar progreso
            const fetchBtn = document.getElementById('fetch-btn');
            fetchBtn.disabled = true;
            
            // Mostrar el bot√≥n de detener
            const stopBtn = document.getElementById('stop-btn');
            stopBtn.style.display = 'inline-block';
            
            isDownloading = true;
            
            document.getElementById('progress-section').style.display = 'block';
            document.getElementById('results-section').style.display = 'none';
            
            // Resetear variables globales
            allComments = [];
            commentsFetched = 0;
            
            try {
                // Primero, obtener informaci√≥n del video incluyendo el n√∫mero de comentarios
                const videoInfo = await fetchVideoInfo(videoId);
                if (!videoInfo) {
                    fetchBtn.disabled = false;
                    return;
                }
                
                videoData.title = videoInfo.title;
                
                // Determinar el n√∫mero total de comentarios para la barra de progreso
                let estimatedTotalComments;
                if (videoInfo.commentCount) {
                    // Usar el n√∫mero real de comentarios si est√° disponible
                    estimatedTotalComments = Math.min(videoInfo.commentCount, 10000);
                    console.log(`El video tiene aproximadamente ${videoInfo.commentCount} comentarios`);
                } else {
                    // Hacer una llamada para obtener el total estimado
                    const initialResponse = await fetch(
                        `https://www.googleapis.com/youtube/v3/commentThreads?part=snippet&videoId=${videoId}&maxResults=1&key=${DEFAULT_API_KEY}`
                    );
                    const initialData = await initialResponse.json();
                    
                    if (initialData.error) {
                        throw new Error(initialData.error.message || "Error al obtener comentarios");
                    }
                    
                    estimatedTotalComments = Math.min(initialData.pageInfo?.totalResults || 2000, 10000);
                }
                
                videoData.totalComments = estimatedTotalComments;
                
                // Establecer valores iniciales en la barra de progreso
                document.getElementById('progress-bar').style.width = '0%';
                document.getElementById('progress-stats').textContent = `0 de ${estimatedTotalComments} comentarios`;
                
                // Siempre ordenar por m√°s recientes (time)
                const order = 'time';
                
                // Obtener todos los comentarios
                await getAllComments(videoId, order, estimatedTotalComments);
                
            } catch (error) {
                console.error("Error al obtener comentarios:", error);
                showError(`Error al obtener comentarios: ${error.message}`);
                fetchBtn.disabled = false;
                isDownloading = false;
            }
        }

        // Funci√≥n para obtener todos los comentarios incluyendo respuestas
        async function getAllComments(videoId, order, estimatedTotal) {
            try {
                let nextPageToken = null;
                let commentsWithReplies = [];
                
                do {
                    // Obtener comentarios principales
                    const response = await fetch(
                        `https://www.googleapis.com/youtube/v3/commentThreads?part=snippet,replies&videoId=${videoId}&maxResults=100&order=${order}${nextPageToken ? `&pageToken=${nextPageToken}` : ''}&key=${DEFAULT_API_KEY}`
                    );
                    
                    const data = await response.json();
                    
                    if (data.error) {
                        throw new Error(data.error.message || "Error al obtener comentarios");
                    }
                    
                    const commentThreads = data.items || [];
                    nextPageToken = data.nextPageToken;
                    
                    // Procesamos cada comentario principal y sus respuestas
                    for (const thread of commentThreads) {
                        const mainComment = {
                            id: thread.id,
                            author: thread.snippet.topLevelComment.snippet.authorDisplayName,
                            text: thread.snippet.topLevelComment.snippet.textDisplay,
                            likeCount: thread.snippet.topLevelComment.snippet.likeCount,
                            publishedAt: thread.snippet.topLevelComment.snippet.publishedAt,
                            replies: []
                        };
                        
                        commentsFetched++;
                        
                        // Si hay respuestas incluidas en los datos iniciales
                        if (thread.replies && thread.replies.comments) {
                            for (const reply of thread.replies.comments) {
                                mainComment.replies.push({
                                    id: reply.id,
                                    author: reply.snippet.authorDisplayName,
                                    text: reply.snippet.textDisplay,
                                    likeCount: reply.snippet.likeCount,
                                    publishedAt: reply.snippet.publishedAt
                                });
                                commentsFetched++;
                            }
                        }
                        
                        // Si hay m√°s respuestas que no se incluyeron en los datos iniciales
                        if (thread.snippet.totalReplyCount > (thread.replies?.comments?.length || 0)) {
                            const additionalReplies = await fetchAdditionalReplies(thread.id, thread.replies?.comments?.length || 0);
                            mainComment.replies = [...mainComment.replies, ...additionalReplies];
                            commentsFetched += additionalReplies.length;
                        }
                        
                        commentsWithReplies.push(mainComment);
                        
                        // Actualizar barra de progreso
                        updateProgressBar(commentsFetched, estimatedTotal);
                    }
                    
                    // Si hay demasiados comentarios, limitamos para evitar exceder cuotas de API
                    if (commentsFetched >= 10000) {
                        nextPageToken = null; // Detener el bucle si llegamos al l√≠mite absoluto
                        console.log("Se alcanz√≥ el l√≠mite m√°ximo de 10,000 comentarios");
                    }
                    
                } while (nextPageToken && isDownloading);
                
                // Guardar todos los comentarios y mostrar resultados
                allComments = commentsWithReplies;
                videoData.totalComments = commentsFetched;
                
                displayResults();
                
                // Habilitar el bot√≥n nuevamente
                document.getElementById('fetch-btn').disabled = false;
                isDownloading = false;
                
            } catch (error) {
                console.error("Error al obtener todos los comentarios:", error);
                showError(`Error al obtener comentarios: ${error.message}`);
                document.getElementById('fetch-btn').disabled = false;
                isDownloading = false;
            }
        }

        // Funci√≥n para obtener respuestas adicionales
        async function fetchAdditionalReplies(parentId, existingRepliesCount) {
            try {
                const replies = [];
                let nextPageToken = null;
                let retriesCount = 0;
                const maxRetries = 3;
                
                do {
                    if (!isDownloading) {
                        // Si se cancel√≥ la descarga, salir del bucle
                        break;
                    }
                    
                    try {
                        // Incrementar contador de solicitudes
                        requestsCount++;
                        
                        // Si estamos cerca del l√≠mite de solicitudes, esperar un poco para evitar bloqueos de la API
                        if (requestsCount % REQUEST_LIMIT === 0) {
                            console.log("Pausando brevemente para evitar l√≠mites de API...");
                            await sleep(3000); // Pausa de 3 segundos
                        } else {
                            // Peque√±a pausa entre solicitudes normales
                            await sleep(REQUEST_DELAY);
                        }
                        
                        const response = await fetch(
                            `https://www.googleapis.com/youtube/v3/comments?part=snippet&parentId=${parentId}&maxResults=100${nextPageToken ? `&pageToken=${nextPageToken}` : ''}&key=${DEFAULT_API_KEY}`
                        );
                        
                        const data = await response.json();
                        
                        if (data.error) {
                            throw new Error(data.error.message || "Error al obtener respuestas");
                        }
                        
                        // Reiniciar contador de reintentos si la solicitud tuvo √©xito
                        retriesCount = 0;
                        
                        const replyItems = data.items || [];
                        nextPageToken = data.nextPageToken;
                        
                        // Si no hay m√°s respuestas, salir del bucle
                        if (replyItems.length === 0) {
                            break;
                        }
                        
                        // Si ya tenemos algunas respuestas, omitirlas para evitar duplicados
                        const startIndex = replies.length < existingRepliesCount ? existingRepliesCount - replies.length : 0;
                        
                        for (let i = startIndex; i < replyItems.length; i++) {
                            const reply = replyItems[i];
                            replies.push({
                                id: reply.id,
                                author: reply.snippet.authorDisplayName,
                                text: reply.snippet.textDisplay,
                                likeCount: reply.snippet.likeCount,
                                publishedAt: reply.snippet.publishedAt
                            });
                        }
                    } catch (error) {
                        console.error("Error al obtener respuestas adicionales:", error);
                        
                        // Si el error es por l√≠mite de cuota, esperar m√°s tiempo
                        if (error.message && error.message.includes("quota")) {
                            console.log("Se alcanz√≥ el l√≠mite de cuota de API. Esperando 30 segundos...");
                            await sleep(30000); // Esperar 30 segundos
                            // No incrementar contador de reintentos para errores de cuota
                        } else {
                            // Incrementar contador de reintentos para otros errores
                            retriesCount++;
                        }
                        
                        if (retriesCount >= maxRetries) {
                            // Si ya se super√≥ el n√∫mero m√°ximo de reintentos, lanzar el error
                            console.error(`Error al obtener respuestas despu√©s de ${maxRetries} intentos: ${error.message}`);
                            break; // Salir del bucle pero no interrumpir todo el proceso
                        }
                        
                        // Esperar un poco antes de reintentar (backoff exponencial)
                        const backoffTime = Math.pow(2, retriesCount) * 1000;
                        console.log(`Reintentando en ${backoffTime/1000} segundos...`);
                        await sleep(backoffTime);
                        
                        // No actualizar nextPageToken para reintentar la misma p√°gina
                        continue;
                    }
                    
                } while (nextPageToken && isDownloading);
                
                return replies;
                
            } catch (error) {
                console.error("Error al obtener respuestas adicionales:", error);
                return []; // Retornar array vac√≠o en caso de error para no interrumpir todo el proceso
            }
        }

        // Funci√≥n para mostrar los resultados
        function displayResults() {
            const resultsSection = document.getElementById('results-section');
            const commentsContainer = document.getElementById('comments-container');
            const videoTitleElement = document.getElementById('video-title');
            const commentsCountElement = document.getElementById('comments-count');
            
            // Ocultar secci√≥n de progreso
            document.getElementById('progress-section').style.display = 'none';
            
            // Limpiar contenedor de comentarios
            commentsContainer.innerHTML = '';
            
            // Actualizar informaci√≥n del video
            videoTitleElement.textContent = videoData.title;
            commentsCountElement.textContent = `${videoData.totalComments} comentarios descargados`;
            
            // Renderizar cada comentario
            allComments.forEach((comment, index) => {
                const commentElement = createCommentElement(comment, index);
                commentsContainer.appendChild(commentElement);
            });
            
            // Mostrar secci√≥n de resultados
            resultsSection.style.display = 'block';
        }

        // Funci√≥n para crear elemento de comentario
        function createCommentElement(comment, index) {
            const commentDiv = document.createElement('div');
            commentDiv.className = 'comment';
            commentDiv.id = `comment-${index + 1}`;
            
            // Crear encabezado del comentario
            const headerDiv = document.createElement('div');
            headerDiv.className = 'comment-header';
            
            // A√±adir n√∫mero de comentario
            const commentNumberSpan = document.createElement('span');
            commentNumberSpan.className = 'comment-number';
            commentNumberSpan.textContent = `#${index + 1} ‚Ä¢ `;
            commentNumberSpan.style.fontWeight = 'bold';
            commentNumberSpan.style.color = '#ff0000';
            commentNumberSpan.style.marginRight = '5px';
            
            const authorSpan = document.createElement('span');
            authorSpan.className = 'comment-author';
            authorSpan.textContent = comment.author;
            
            const dateSpan = document.createElement('span');
            dateSpan.className = 'comment-date';
            dateSpan.textContent = formatDate(comment.publishedAt);
            
            headerDiv.appendChild(commentNumberSpan);
            headerDiv.appendChild(authorSpan);
            headerDiv.appendChild(dateSpan);
            
            // Crear texto del comentario
            const textDiv = document.createElement('div');
            textDiv.className = 'comment-text';
            textDiv.innerHTML = comment.text;
            
            // Crear metadatos del comentario
            const metaDiv = document.createElement('div');
            metaDiv.className = 'comment-meta';
            
            const likesSpan = document.createElement('span');
            likesSpan.innerHTML = `<i class="fas fa-thumbs-up"></i> ${comment.likeCount}`;
            
            metaDiv.appendChild(likesSpan);
            
            // A√±adir elementos al comentario principal
            commentDiv.appendChild(headerDiv);
            commentDiv.appendChild(textDiv);
            commentDiv.appendChild(metaDiv);
            
            // Si hay respuestas, a√±adirlas
            if (comment.replies && comment.replies.length > 0) {
                const repliesDiv = document.createElement('div');
                repliesDiv.className = 'replies-container';
                
                comment.replies.forEach((reply, replyIndex) => {
                    const replyDiv = document.createElement('div');
                    replyDiv.className = 'reply';
                    replyDiv.id = `reply-${index + 1}-${replyIndex + 1}`;
                    
                    // Encabezado de la respuesta
                    const replyHeaderDiv = document.createElement('div');
                    replyHeaderDiv.className = 'comment-header';
                    
                    // A√±adir n√∫mero de respuesta (formato: CommentNum.ReplyNum)
                    const replyNumberSpan = document.createElement('span');
                    replyNumberSpan.className = 'reply-number';
                    replyNumberSpan.textContent = `#${index + 1}.${replyIndex + 1} ‚Ä¢ `;
                    replyNumberSpan.style.fontWeight = 'bold';
                    replyNumberSpan.style.color = '#4285f4';
                    replyNumberSpan.style.marginRight = '5px';
                    
                    const replyAuthorSpan = document.createElement('span');
                    replyAuthorSpan.className = 'comment-author';
                    replyAuthorSpan.textContent = reply.author;
                    
                    const replyDateSpan = document.createElement('span');
                    replyDateSpan.className = 'comment-date';
                    replyDateSpan.textContent = formatDate(reply.publishedAt);
                    
                    replyHeaderDiv.appendChild(replyNumberSpan);
                    replyHeaderDiv.appendChild(replyAuthorSpan);
                    replyHeaderDiv.appendChild(replyDateSpan);
                    
                    // Texto de la respuesta
                    const replyTextDiv = document.createElement('div');
                    replyTextDiv.className = 'comment-text';
                    replyTextDiv.innerHTML = reply.text;
                    
                    // Metadatos de la respuesta
                    const replyMetaDiv = document.createElement('div');
                    replyMetaDiv.className = 'comment-meta';
                    
                    const replyLikesSpan = document.createElement('span');
                    replyLikesSpan.innerHTML = `<i class="fas fa-thumbs-up"></i> ${reply.likeCount}`;
                    
                    replyMetaDiv.appendChild(replyLikesSpan);
                    
                    // A√±adir elementos a la respuesta
                    replyDiv.appendChild(replyHeaderDiv);
                    replyDiv.appendChild(replyTextDiv);
                    replyDiv.appendChild(replyMetaDiv);
                    
                    repliesDiv.appendChild(replyDiv);
                });
                
                commentDiv.appendChild(repliesDiv);
            }
            
            return commentDiv;
        }

        // Funci√≥n para descargar comentarios como archivo de texto
        function downloadAsTxt() {
            // Crear contenido del archivo
            let content = `T√≠tulo del video: ${videoData.title}\n`;
            content += `Total de comentarios: ${videoData.totalComments}\n`;
            content += `Fecha de descarga: ${new Date().toLocaleDateString()}\n\n`;
            content += `====================\n\n`;
            
            // A√±adir cada comentario y sus respuestas
            allComments.forEach((comment, index) => {
                content += `[COMENTARIO #${index + 1}]\n`;
                content += `Autor: ${comment.author}\n`;
                content += `Fecha: ${formatDate(comment.publishedAt)}\n`;
                content += `Likes: ${comment.likeCount}\n`;
                content += `Comentario: ${comment.text.replace(/<[^>]*>/g, '')}\n\n`;
                
                // A√±adir respuestas si las hay
                if (comment.replies && comment.replies.length > 0) {
                    content += `---- Respuestas (${comment.replies.length}) ----\n\n`;
                    
                    comment.replies.forEach((reply, replyIndex) => {
                        content += `  [RESPUESTA #${index + 1}.${replyIndex + 1}]\n`;
                        content += `  Autor: ${reply.author}\n`;
                        content += `  Fecha: ${formatDate(reply.publishedAt)}\n`;
                        content += `  Likes: ${reply.likeCount}\n`;
                        content += `  Respuesta: ${reply.text.replace(/<[^>]*>/g, '')}\n\n`;
                    });
                }
                
                content += `====================\n\n`;
            });
            
            // Crear y descargar el archivo
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            
            // Generar nombre de archivo basado en el t√≠tulo del video
            const fileName = `${videoData.title.replace(/[^\w\s]/gi, '')}_comentarios.txt`;
            
            a.href = url;
            a.download = fileName;
            a.click();
            
            // Liberar la URL creada
            URL.revokeObjectURL(url);
        }

        // Funci√≥n para descargar comentarios como PDF
        function downloadAsPdf() {
            // Inicializar jsPDF
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // Definir m√°rgenes y posici√≥n inicial
            const margin = 15;
            let y = margin;
            
            // Configurar fuente y tama√±o
            doc.setFont('helvetica', 'normal');
            
            // A√±adir t√≠tulo del documento
            doc.setFontSize(16);
            doc.setFont('helvetica', 'bold');
            doc.text('Comentarios de YouTube', margin, y);
            y += 10;
            
            // A√±adir informaci√≥n del video
            doc.setFontSize(12);
            doc.setFont('helvetica', 'normal');
            doc.text(`T√≠tulo del video: ${videoData.title}`, margin, y);
            y += 7;
            
            doc.text(`Total de comentarios: ${videoData.totalComments}`, margin, y);
            y += 7;
            
            doc.text(`Fecha de descarga: ${new Date().toLocaleDateString()}`, margin, y);
            y += 10;
            
            // Funci√≥n para verificar si necesitamos una nueva p√°gina
            function checkForNewPage(heightNeeded) {
                if (y + heightNeeded > doc.internal.pageSize.height - margin) {
                    doc.addPage();
                    y = margin;
                    return true;
                }
                return false;
            }
            
            // Funci√≥n para a√±adir texto con saltos de l√≠nea autom√°ticos
            function addWrappedText(text, x, y, maxWidth) {
                // Limpiar HTML tags
                const cleanText = text.replace(/<[^>]*>/g, '');
                
                // Dividir el texto en l√≠neas que caben en el ancho m√°ximo
                const lines = doc.splitTextToSize(cleanText, maxWidth);
                
                // Verificar si necesitamos nueva p√°gina
                if (checkForNewPage(lines.length * 7)) {
                    y = margin;
                }
                
                // A√±adir l√≠neas
                doc.text(lines, x, y);
                
                // Actualizar posici√≥n Y
                y += lines.length * 7;
                
                return y;
            }
            
            // A√±adir cada comentario y sus respuestas
            allComments.forEach((comment, index) => {
                // Verificar si necesitamos nueva p√°gina para este comentario
                checkForNewPage(50); // Estimaci√≥n de altura m√≠nima para un comentario
                
                // Separador
                doc.setDrawColor(200);
                doc.line(margin, y, doc.internal.pageSize.width - margin, y);
                y += 5;
                
                // N√∫mero y autor del comentario
                doc.setFont('helvetica', 'bold');
                doc.setTextColor(255, 0, 0); // Color rojo para n√∫mero de comentario
                doc.text(`COMENTARIO #${index + 1}`, margin, y);
                doc.setTextColor(0, 0, 0); // Volver a color negro
                doc.text(` - ${comment.author}`, margin + doc.getTextWidth(`COMENTARIO #${index + 1}`), y);
                y += 7;
                
                // Metadatos del comentario
                doc.setFont('helvetica', 'italic');
                doc.setFontSize(10);
                doc.text(`Fecha: ${formatDate(comment.publishedAt)} | Likes: ${comment.likeCount}`, margin, y);
                y += 7;
                
                // Texto del comentario
                doc.setFont('helvetica', 'normal');
                doc.setFontSize(11);
                y = addWrappedText(comment.text, margin, y, doc.internal.pageSize.width - margin * 2);
                y += 5;
                
                // A√±adir respuestas si las hay
                if (comment.replies && comment.replies.length > 0) {
                    doc.setFont('helvetica', 'bold');
                    doc.setFontSize(10);
                    doc.text(`Respuestas (${comment.replies.length}):`, margin + 5, y);
                    y += 5;
                    
                    // Recorrer las respuestas
                    comment.replies.forEach((reply, replyIndex) => {
                        checkForNewPage(30); // Estimaci√≥n de altura m√≠nima para una respuesta
                        
                        // Indentaci√≥n para respuestas
                        const replyMargin = margin + 10;
                        
                        // N√∫mero y autor de la respuesta
                        doc.setFont('helvetica', 'bold');
                        doc.setFontSize(10);
                        doc.setTextColor(66, 133, 244); // Color azul para n√∫mero de respuesta
                        doc.text(`RESPUESTA #${index + 1}.${replyIndex + 1}`, replyMargin, y);
                        doc.setTextColor(0, 0, 0); // Volver a color negro
                        doc.text(` - ${reply.author}`, replyMargin + doc.getTextWidth(`RESPUESTA #${index + 1}.${replyIndex + 1}`), y);
                        y += 5;
                        
                        // Metadatos de la respuesta
                        doc.setFont('helvetica', 'italic');
                        doc.setFontSize(9);
                        doc.text(`Fecha: ${formatDate(reply.publishedAt)} | Likes: ${reply.likeCount}`, replyMargin, y);
                        y += 5;
                        
                        // Texto de la respuesta
                        doc.setFont('helvetica', 'normal');
                        doc.setFontSize(10);
                        y = addWrappedText(reply.text, replyMargin, y, doc.internal.pageSize.width - replyMargin - margin);
                        y += 3;
                    });
                }
                
                y += 5;
            });
            
            // Generar nombre de archivo basado en el t√≠tulo del video
            const fileName = `${videoData.title.replace(/[^\w\s]/gi, '')}_comentarios.pdf`;
            
            // Guardar el PDF
            doc.save(fileName);
        }
    </script>
</body>
</html>